# version: 2
# jobs:
#   test:
#     docker:
#       - image: circleci/openjdk:11-jdk
#     steps:
#       - checkout
#       - run: ./gradlew check
#       - run:
#           name: Save test results
#           command: |
#             mkdir -p ~/test-results/junit/
#             find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/test-results/junit/ \;
#           when: always
#       - store_test_results:
#           path: ~/test-results
#       - store_artifacts:
#           path: ~/test-results/junit
# workflows:
#   version: 2
#   build_and_test:
#     jobs:
#       - test

version: 2.1

orbs:
  aws-cli: circleci/aws-cli@4.0.0 # use v4 of this orb
  aws-ecr: circleci/aws-ecr@8.2.1 # this orb doesn't support OIDC v2, so we use aws-cli to authenticate

commands:
  build-image:
    description: "Build application image"
    steps:
      - run:
          name: Set up the image for building # Alternatively we may wish to use circleci/openjdk:11-jdk, unsure how openjdk-8 is used though
          command: |
            # apt-get update -y
            # add-apt-repository ppa:openjdk-r/ppa
            # apt-get update -y
            # apt-get install openjdk-8-jdk -y
            # update-ca-certificates -f
            # apt-get install openjdk-11-jdk -y
            # update-ca-certificates -f
      - run:
          name: Building the docker image
          command: |
            echo Building the jar file image...
            chmod +x ./gradlew && ./gradlew build
            echo Building the Docker image...
            docker build -f Dockerfile_cp -t laa-not-on-libra-autosearch .
            zip -rq buildreports.zip ./build/reports/tests/test/*
  deploy-app:
    description: "Deploy the application to the relevant environment"
    parameters:
      value_file:
        type: string
    steps:
    - run:
        name: Authenticate with K8s cluster
        command: |
          echo -n ${K8S_CLUSTER_CERT} | base64 -d > ./ca.crt
          kubectl config set-cluster ${K8S_CLUSTER_NAME} --certificate-authority=./ca.crt --server=https://${K8S_CLUSTER_NAME}
          kubectl config set-credentials cd-serviceaccount --token=${K8S_TOKEN}
          kubectl config set-context ${K8S_CLUSTER_NAME} --cluster=${K8S_CLUSTER_NAME} --user=cd-serviceaccount --namespace=${K8S_NAMESPACE}
          kubectl config use-context ${K8S_CLUSTER_NAME}
          kubectl --namespace=${K8S_NAMESPACE} get pods
    - run:
        name: helm upgrade
        command: |
          cd helm_deploy/nolasa
          helm upgrade nolasa -f << parameters.value_file >> . --namespace ${K8S_NAMESPACE} --install --set nolasa.image.tag=${DOCKER_IMAGE_TAG}


jobs:
  build_app:
    docker:
    - image: circleci/openjdk:11-jdk # ministryofjustice/cloud-platform-tools
    environment:
      DOCKER_IMAGE_TAG: laa-not-on-libra-autosearch-${CIRCLE_SHA1}
    steps:
    - checkout
    - setup_remote_docker:
        docker_layer_caching: true
        version: 20.10.6
    - build-image
  push_image:
    executor: aws-ecr/default
    environment:
      DOCKER_IMAGE_TAG: laa-not-on-libra-autosearch-${CIRCLE_SHA1}
    steps:
      # Authenticate to AWS using OIDC v2 with the AWS CLI
      - aws-cli/setup:
          role_arn: $ECR_ROLE_TO_ASSUME # this will use the env var
          region: $ECR_REGION # this will use the env var
      # Authenticate to the ECR repository using the standard command
      - run:
          name: Log in to ECR
          command: |
            aws ecr get-login-password --region $ECR_REGION | docker login --username AWS --password-stdin ${AWS_ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com
      - aws-ecr/push-image:
          tag: $DOCKER_IMAGE_TAG
          region: $ECR_REGION # this will use the env var
          repo: $ECR_REPOSITORY # this will use the env var
      - run:
          name: Push application Docker image
          command: |
            # ecr_login="$(AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION} AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} ECR_ENDPOINT=${ECR_ENDPOINT} aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_ENDPOINT)"
            #
            # docker tag laa-not-on-libra-autosearch "${ECR_ENDPOINT}:${DOCKER_IMAGE_TAG}"
            # docker push "${ECR_ENDPOINT}:${DOCKER_IMAGE_TAG}"
            echo '{ "tag":"${DOCKER_IMAGE_TAG}" }' >> build_tag.json
            cat build_tag.json
            pwd

            # if [ "${CIRCLE_BRANCH}" == "main" ]; then
            #   docker tag app "${ECR_ENDPOINT}:latest"
            #   docker push "${ECR_ENDPOINT}:latest"
            # fi
      # # - store_artifacts:
      # #     path: .
      # #     destination: image-build
  deploy_to_dev:
    docker:
    - image: ministryofjustice/cloud-platform-tools
    environment:
      DOCKER_IMAGE_TAG: laa-not-on-libra-autosearch-${CIRCLE_SHA1}
    steps:
      - checkout
      # - setup_remote_docker:
      #     docker_layer_caching: true
      #     version: 20.10.6
      - deploy-app:
          value_file: values_dev.yaml


workflows:
  version: 2
  multi_env_deploy:
    jobs:
      - build_app
          # context: TBD # this would be the central namespace where we push images
      - push_image:
          requires:
            - build_app
          # context: TBD
      # - deploy_app:
      #     context: TBD
