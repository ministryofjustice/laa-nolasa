# version: 2
# jobs:
#   test:
#     docker:
#       - image: circleci/openjdk:11-jdk
#     steps:
#       - checkout
#       - run: ./gradlew check
#       - run:
#           name: Save test results
#           command: |
#             mkdir -p ~/test-results/junit/
#             find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/test-results/junit/ \;
#           when: always
#       - store_test_results:
#           path: ~/test-results
#       - store_artifacts:
#           path: ~/test-results/junit
# workflows:
#   version: 2
#   build_and_test:
#     jobs:
#       - test

version: 2.1

commands:
  build-image:
    description: "Build image and push to ECR"
    steps:
      - run:
          name: Set up the image for building # Alternatively we may wish to use circleci/openjdk:11-jdk, unsure how openjdk-8 is used though
          command: |
            apt-get update -y
            add-apt-repository ppa:openjdk-r/ppa
            apt-get update -y
            apt-get install openjdk-8-jdk -y
            update-ca-certificates -f
            apt-get install openjdk-11-jdk -y
            update-ca-certificates -f
      - run:
          name: Building the docker image
          command: |
            echo Building the jar file image...
            chmod +x ./gradlew && ./gradlew build
            echo Building the Docker image...
            docker build -f Dockerfile_cp -t laa-not-on-libra-autosearch .
            zip -rq buildreports.zip ./build/reports/tests/test/*
      - run:
          name: Push application Docker image
          command: |
            login="$(AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION} AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} aws ecr get-login --no-include-email)"
            ${login}
            docker tag laa-not-on-libra-autosearch "${ECR_ENDPOINT}:${DOCKER_IMAGE_TAG}"
            docker push "${ECR_ENDPOINT}:${DOCKER_IMAGE_TAG}"
            echo '{ "tag":"${DOCKER_IMAGE_TAG}" }' >> build_tag.json
            cat build_tag.json
            pwd
      # - store_artifacts:
      #     path: .
      #     destination: image-build
  deploy-app:
    description: "Deploy the application to the relevant environment"
    parameters:
      value_file:
        type: string
    steps:
    - run:
        name: Authenticate with K8s cluster
        command: |
          echo -n ${K8S_CLUSTER_CERT} | base64 -d > ./ca.crt
          kubectl config set-cluster ${K8S_CLUSTER_NAME} --certificate-authority=./ca.crt --server=https://${K8S_CLUSTER_NAME}
          kubectl config set-credentials cd-serviceaccount --token=${K8S_TOKEN}
          kubectl config set-context ${K8S_CLUSTER_NAME} --cluster=${K8S_CLUSTER_NAME} --user=cd-serviceaccount --namespace=${K8S_NAMESPACE}
          kubectl config use-context ${K8S_CLUSTER_NAME}
          kubectl --namespace=${K8S_NAMESPACE} get pods
    - run:
        name: helm upgrade
        command: |
          cd helm_deploy/nolasa
          helm upgrade nolasa -f << parameters.value_file >> . --namespace ${K8S_NAMESPACE} --install --set nolasa.image.tag=${DOCKER_IMAGE_TAG}


jobs:
  build_app:
    docker:
    - image: ministryofjustice/cloud-platform-tools
    environment:
      DOCKER_IMAGE_TAG: laa-not-on-libra-autosearch-${CIRCLE_SHA1}
    steps:
    - checkout
    - setup_remote_docker:
        docker_layer_caching: true
        version: 20.10.6
    - build-image
  deploy_to_dev:
    docker:
    - image: ministryofjustice/cloud-platform-tools
    environment:
      DOCKER_IMAGE_TAG: laa-not-on-libra-autosearch-${CIRCLE_SHA1}
    steps:
      - checkout
      # - setup_remote_docker:
      #     docker_layer_caching: true
      #     version: 20.10.6
      - deploy-app:
          value_file: values_dev.yaml


workflows:
  version: 2
  multi_env_deploy:
    jobs:
      - build_app:
          context: TBD # this would be the central namespace where we push images
      # - deploy_app:
      #     context: TBD
