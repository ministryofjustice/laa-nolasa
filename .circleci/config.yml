# version: 2
# jobs:
#   test:
#     docker:
#       - image: circleci/openjdk:11-jdk
#     steps:
#       - checkout
#       - run: ./gradlew check
#       - run:
#           name: Save test results
#           command: |
#             mkdir -p ~/test-results/junit/
#             find . -type f -regex ".*/build/test-results/.*xml" -exec cp {} ~/test-results/junit/ \;
#           when: always
#       - store_test_results:
#           path: ~/test-results
#       - store_artifacts:
#           path: ~/test-results/junit
# workflows:
#   version: 2
#   build_and_test:
#     jobs:
#       - test

version: 2.1

orbs:
  aws-cli: circleci/aws-cli@4.0.0 # use v4 of this orb
  aws-ecr: circleci/aws-ecr@8.2.1 # this orb doesn't support OIDC v2, so we use aws-cli to authenticate

commands:
  build-image:
    description: "Build application image"
    steps:
      - run:
          name: Set up the image for building # Alternatively we may wish to use circleci/openjdk:11-jdk, unsure how openjdk-8 is used though
          command: |
            # apt-get update -y
            # add-apt-repository ppa:openjdk-r/ppa
            # apt-get update -y
            # apt-get install openjdk-8-jdk -y
            # update-ca-certificates -f
            # apt-get install openjdk-11-jdk -y
            # update-ca-certificates -f
      - run:
          name: Building the docker image
          command: |
            echo Building the jar file image...
            chmod +x ./gradlew && ./gradlew build
            echo Building the Docker image...
            docker build -f Dockerfile_cp -t "${AWS_ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com/${DOCKER_IMAGE_NAME}:${CIRCLE_SHA1}" --no-cache .
            zip -rq buildreports.zip ./build/reports/tests/test/*
  deploy-app:
    description: "Deploy the application to the relevant environment"
    parameters:
      value_file:
        type: string
    steps:
    - run:
        name: Authenticate with K8s cluster
        command: |
          echo -n ${K8S_CLUSTER_CERT} | base64 -d > ./ca.crt
          kubectl config set-cluster ${K8S_CLUSTER_NAME} --certificate-authority=./ca.crt --server=https://${K8S_CLUSTER_NAME}
          kubectl config set-credentials cd-serviceaccount --token=${K8S_TOKEN}
          kubectl config set-context ${K8S_CLUSTER_NAME} --cluster=${K8S_CLUSTER_NAME} --user=cd-serviceaccount --namespace=${K8S_NAMESPACE}
          kubectl config use-context ${K8S_CLUSTER_NAME}
          kubectl --namespace=${K8S_NAMESPACE} get pods
    - run:
        name: helm upgrade
        command: |
          cd helm_deploy/nolasa
          # if [ "${CIRCLE_BRANCH}" == "main" ]; then
          helm upgrade nolasa -f << parameters.value_file >> . --namespace ${K8S_NAMESPACE} --install --set nolasa.image.tag=${CIRCLE_SHA1}
          # fi
          kubectl --namespace=${K8S_NAMESPACE} get pods

jobs:
  build_and_push_image:
    docker:
    - image: circleci/openjdk:11-jdk # ministryofjustice/cloud-platform-tools
    environment:
      DOCKER_IMAGE_NAME: laa-aws-infrastructure/laa-not-on-libra-auto-search-application-dev-ecr
    steps:
    - checkout
    - setup_remote_docker:
        docker_layer_caching: true
        version: 17.09
    - build-image
    # Authenticate to AWS using OIDC v2 with the AWS CLI
    - aws-cli/setup:
        role_arn: $ECR_ROLE_TO_ASSUME # this will use the env var
        region: $ECR_REGION # this will use the env var
    # Authenticate to the ECR repository using the standard command
    - run:
        name: Log in to ECR
        command: |
          aws ecr get-login-password --region $ECR_REGION | docker login --username AWS --password-stdin ${AWS_ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com

    # - aws-ecr/push-image:
    #     tag: ${CIRCLE_SHA1}
    #     region: $ECR_REGION # this will use the env var
    #     repo: $ECR_REPOSITORY # this will use the env var
    - run:
        name: Push application Docker image
        command: |
          # ecr_login="$(AWS_DEFAULT_REGION=${AWS_DEFAULT_REGION} AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID} AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY} ECR_ENDPOINT=${ECR_ENDPOINT} aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_ENDPOINT)"

          # docker tag ${DOCKER_IMAGE_NAME} "${AWS_ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com/${DOCKER_IMAGE_NAME}:${CIRCLE_SHA1}"
          docker push "${AWS_ECR_REGISTRY_ID}.dkr.ecr.${ECR_REGION}.amazonaws.com/${DOCKER_IMAGE_NAME}:${CIRCLE_SHA1}"
          echo '{ "tag":"${CIRCLE_SHA1}" }' >> build_tag.json
          cat build_tag.json
          pwd

          # if [ "${CIRCLE_BRANCH}" == "main" ]; then
          #   docker tag app "${ECR_ENDPOINT}:latest"
          #   docker push "${ECR_ENDPOINT}:latest"
          # fi
    # # - store_artifacts:
    # #     path: .
    # #     destination: image-build


  deploy_to_dev:
    docker:
    - image: ministryofjustice/cloud-platform-tools
    environment:
      DOCKER_IMAGE_NAME: laa-aws-infrastructure/laa-not-on-libra-auto-search-application-dev-ecr
    steps:
      - checkout
      - setup_remote_docker:
          docker_layer_caching: true
          version: 17.09
      - deploy-app:
          value_file: values_dev.yaml


workflows:
  version: 2
  multi_env_deploy:
    jobs:
      - build_and_push_image
          # context: TBD # this would be the central namespace where we push images
      # - deploy_app:
      #     context: TBD
